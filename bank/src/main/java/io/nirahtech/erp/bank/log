package io.nirahtech.erp.bank;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Currency;
import java.util.Objects;
import java.util.Set;

public record AccountHolder(
    String firstName,
    String lastName,
    LocalDate birthDate,
    Set<BankAccount> bankAccounts
) {


    public void debt(BigDecimal amount, Currency currency, Debtor debtor, Credit credit) {
        if (Objects.isNull(amount) || Objects.isNull(currency) || Objects.isNull(debtor) ||Objects.isNull(credit)) {
            throw new RuntimeException();
        }

        if (this.bankAccounts.contains(debtor)) {
            debtor.debt(amount, currency);
        }
    }

    public void credit(BigDecimal amount, Currency currency, Debtor debtor, Credit credit) {
        if (Objects.isNull(amount) || Objects.isNull(currency) || Objects.isNull(debtor) ||Objects.isNull(credit)) {
            throw new RuntimeException();
        }

        if (this.bankAccounts.contains(credit)) {
            credit.credit(amount, currency);
        }
    }

    public void transferMoney(BankAccount debtor, BankAccount credit, BigDecimal amount, Currency currency) {
        FinancialTransaction financialTransaction = FinancialTransactionFactory.create(debtor, amount, credit);

    }

}
package io.nirahtech.erp.bank;

public record AccountNumber(String value) {
    
}
package io.nirahtech.erp.bank;

public final class BankAccountFactory {
    private BankAccountFactory() { }

    public static final BankAccount create(BankAccountType accountType, final Bank bank, final BranchCode branchCode, final AccountHolder accountHolder) {
        final BankDetails bankDetails = BankDetailsFactory.create(bank, branchCode, accountHolder);
        return new BankAccount(accountType, bank, accountHolder, bankDetails);
    }
}
package io.nirahtech.erp.bank;

import java.io.Serializable;
import java.math.BigDecimal;
import java.util.Currency;

public final class BankAccount implements Serializable, Debtor, Credit {
    private final BankDetails bankDetails;
    private final BankAccountType accountType;
    private final Bank bank;
    private final AccountHolder accountHolder;
    private BigDecimal balance = BigDecimal.valueOf(0.0F);
    private final FinancialTransactionLogbook financialTransactionLogbook;

    public BankAccount(final BankAccountType accountType, final Bank bank, final AccountHolder accountHolder, final BankDetails bankDetails) {
        this.bank = bank;
        this.accountType = accountType;
        this.accountHolder = accountHolder;
        this.bankDetails = bankDetails;
        this.financialTransactionLogbook = new FinancialTransactionLogbook();
    }
    public BankAccountType getAccountType() {
        return accountType;
    }

    public final BigDecimal getBalance() {
        return this.balance;
    }
    public final Bank getBank() {
        return this.bank;
    }
    public final BankDetails getBankDetails() {
        return this.bankDetails;
    }

    public final AccountHolder getAccountHolder() {
        return this.accountHolder;
    }

    public FinancialTransactionLogbook getFinancialTransactionLogbook() {
        return financialTransactionLogbook;
    }

    public final void close() {

    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append(String.format("%s[bankDetails$%s, bank=%s, balance=%s, accountHolder=%s]", this.getClass().getSimpleName(), this.bankDetails, this.bank, this.balance, this.accountHolder));
        return builder.toString();
    }

    @Override
    public void credit(BigDecimal amount, Currency currency) {
        this.balance = this.balance.add(amount);
    }

    @Override
    public void debt(BigDecimal amount, Currency currency) {
        this.balance = this.balance.subtract(amount);
    }
}
package io.nirahtech.erp.bank;

import java.util.Collection;

public interface BankAccountManager {
    BankAccount openNewBankAccount(final BankAccountType accountType, final AccountHolder customer);
    void closeBankAccount(final BankAccount bankAccount); 
    Collection<BankAccount> listBankAccounts();
}
package io.nirahtech.erp.bank;

public enum BankAccountType {
    COMPANY_ACCOUNT,
    STUDENT_BANK_ACCOUNT,
    INDIVIDUAL_RETIREMENT_ACCOUNT,
    DEPOSIT_CERTIFICATE_ACOUNT,
    MONEY_MARKER_ACCOUNT,
    SAVINGS_ACCOUNT,
    CURRENT_ACCOUNT;
}
package io.nirahtech.erp.bank;

public record BankCode(String value) {
    
}
package io.nirahtech.erp.bank;

import java.util.Collection;

public interface BankCustomerManager {
    void registerNewCustomer(final AccountHolder customer);
    void disaffiliateCustomer(final AccountHolder customer); 
    Collection<AccountHolder> listCustomers();
}
package io.nirahtech.erp.bank;

import java.util.Optional;
import java.util.UUID;

public final class BankDetailsFactory {
    private BankDetailsFactory() { }

    public static final BankDetails create(final Bank bank, final BranchCode branchCode, final AccountHolder accountHolder) {
        final UUID accountNumberUUID = UUID.randomUUID();
        final AccountNumber accountNumber = new AccountNumber(accountNumberUUID.toString().replace("-", "").substring(0, 30));
        return new BankDetails(
            accountHolder, 
            bank.name(), 
            bank.code(), 
            "null", 
            accountNumber, 
            "null", 
            new InternationalBankAccountNumber(
                bank.country(),
                76,
                new BasicBankAccountNumber(
                    bank.code(),
                    branchCode,
                    accountNumber
                )
            ), 
            new BankIdentifierCode(
                bank.code(),
                bank.country(),
                branchCode,
                Optional.empty()
            ));
    }
}
package io.nirahtech.erp.bank;

public record BankDetails(
    AccountHolder accountHolder,
    String bankName,
    BankCode bankCode,
    String ticketOfficeCode,
    AccountNumber bankAccountNumber,
    String bankDetailsCode,
    InternationalBankAccountNumber iban,
    BankIdentifierCode bic
) {
    
}
package io.nirahtech.erp.bank;

import java.util.HashSet;
import java.util.Locale;

public final class BankFactory {
    private BankFactory() { }

    public static final Bank create(final String name, final BankCode code, final BranchCode branchCode, final Locale country) {
        return new Bank(name, code, branchCode, country, new HashSet<>(), new HashSet<>());
    }

}
package io.nirahtech.erp.bank;

import java.text.ParseException;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;

public final record BankIdentifierCode (
    BankCode bankNameCode,
    Locale country,
    BranchCode bankBranchCode,
    Optional<String> branchCode
) {

    private static final int MAX_BIC_SIZE = 11;

    public static final BankIdentifierCode parse(final String bic) throws ParseException {
        if (Objects.isNull(bic)) {
            throw new ParseException("BIC cannot be 'null'.", 0);
        }
        if (bic.length() > MAX_BIC_SIZE) {
            throw new ParseException("BIC size cannot be greater than " + MAX_BIC_SIZE, 0);
        }
        for (final char character : bic.toCharArray()) {
            if (!Character.isLetterOrDigit(character)) {
                throw new ParseException("Invalid character detected in BIC : " + character, 0);
            }
        }

        final String bankCodeValue = bic.substring(0, 4);
        final String countryCodeValue = bic.substring(4, 6);
        final String bankBranchCodeValue = bic.substring(6, 8);
        final Optional<String> branchCodeValue = Optional.ofNullable(bic.substring(8));

        final Locale country = Locale.forLanguageTag(countryCodeValue);

        return new BankIdentifierCode(new BankCode(bankCodeValue), country, new BranchCode(bankBranchCodeValue), branchCodeValue);
    }
    
}
package io.nirahtech.erp.bank;

import java.util.Collection;
import java.util.Collections;
import java.util.Locale;
import java.util.Objects;
import java.util.Set;

public final record Bank(
    String name,
    BankCode code,
    BranchCode branchCode,
    Locale country,
    Set<BankAccount> accounts,
    Set<AccountHolder> customers
) implements BankAccountManager, BankCustomerManager {

    @Override
    public void registerNewCustomer(AccountHolder customer) {
        if (Objects.nonNull(customer)) {
            this.customers.add(customer);
        }
    }

    @Override
    public void disaffiliateCustomer(AccountHolder customer) {
        if (Objects.nonNull(customer)) {
            this.customers.remove(customer);
            customer.bankAccounts().forEach(account -> {
                this.closeBankAccount(account);
            });
        }

    }

    @Override
    public Collection<AccountHolder> listCustomers() {
        return Collections.unmodifiableCollection(this.customers);
    }

    @Override
    public BankAccount openNewBankAccount(final BankAccountType accountType, final AccountHolder customer) {
        BankAccount account = BankAccountFactory.create(accountType, this, branchCode, customer);
        this.accounts.add(account);
        return account;
    }

    @Override
    public void closeBankAccount(BankAccount bankAccount) {
        if (Objects.nonNull(bankAccount)) {
            bankAccount.close();
        }
    }

    @Override
    public Collection<BankAccount> listBankAccounts() {
        return Collections.unmodifiableCollection(this.accounts);
    }
    
}
package io.nirahtech.erp.bank;

import java.text.ParseException;
import java.util.Objects;

public record BasicBankAccountNumber(
    BankCode bankCode,
    BranchCode branchCode,
    AccountNumber accountNumber
) {
    
    private static final int MAX_IBAN_SIZE = 30;

    public static final BasicBankAccountNumber parse(final String bban)  throws ParseException {
        if (Objects.isNull(bban)) {
            throw new ParseException("BBAN cannot be 'null'.", 0);
        }
        if (bban.length() > MAX_IBAN_SIZE) {
            throw new ParseException("BBAN size cannot be greater than " + MAX_IBAN_SIZE, 0);
        }
        for (final char character : bban.toCharArray()) {
            if (!Character.isLetterOrDigit(character)) {
                throw new ParseException("Invalid character detected in BBAN : " + character, 0);
            }
        }

        final String bankCodeValue = bban.substring(0, 4);
        final String branchCodeValue = bban.substring(4, 9);
        final String accountNumberValue = bban.substring(9);
        
        return new BasicBankAccountNumber(new BankCode(bankCodeValue), new BranchCode(branchCodeValue), new AccountNumber(accountNumberValue));
    }

}
package io.nirahtech.erp.bank;

import java.text.ParseException;

public final class BBANFactory {
    private BBANFactory() { }

    public static final BasicBankAccountNumber create(final String bban) throws ParseException {
        return BasicBankAccountNumber.parse(bban);
    }
}
package io.nirahtech.erp.bank;

import java.text.ParseException;

public final class BICFactory {
    private BICFactory() { }

    public static final BankIdentifierCode create(final String bic) throws ParseException {
        return BankIdentifierCode.parse(bic);
    }
}
package io.nirahtech.erp.bank;

public record BranchCode(String value) {
    
}
package io.nirahtech.erp.bank;

import java.math.BigDecimal;
import java.util.Currency;

public interface Credit {
    void credit(BigDecimal amount, Currency currency);
}
package io.nirahtech.erp.bank;

import java.math.BigDecimal;
import java.util.Currency;

public interface Debtor {
    void debt(BigDecimal amount, Currency currency);
}
package io.nirahtech.erp.bank;

public class FinancialRule {
    
}
package io.nirahtech.erp.bank;

public interface FinancialService {
    
}
package io.nirahtech.erp.bank;

public interface FinancialTransactionExecutor {
    void execute(FinancialTransaction transaction);
}
package io.nirahtech.erp.bank;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Currency;
import java.util.UUID;

public final class FinancialTransactionFactory {
    private FinancialTransactionFactory() { }

    public static final FinancialTransaction create(Debtor debtor, BigDecimal amount, Credit credit) {
        return FinancialTransactionFactory.create(debtor, amount, Currency.getInstance(((BankAccount)debtor).getBank().country()), credit);
    }
    
    public static final FinancialTransaction create(Debtor debtor, BigDecimal amount, Currency currency, Credit credit) {
        return new FinancialTransaction(UUID.randomUUID(), LocalDateTime.now(), amount, currency, credit, debtor);
    }
}
package io.nirahtech.erp.bank;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Currency;
import java.util.UUID;

public record FinancialTransaction(
    UUID id,
    LocalDateTime timestamp,
    BigDecimal amount,
    Currency currency,
    Credit credit,
    Debtor debtor
) {

}
package io.nirahtech.erp.bank;

import java.time.LocalDateTime;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public final class FinancialTransactionLogbook {
    private boolean isReadOnly = false;
    private final Set<FinancialTransaction> transactions = new HashSet<>();

    public FinancialTransactionLogbook() {

    }

    public final Collection<FinancialTransaction> getTransactions() {
        return Collections.unmodifiableCollection(this.transactions);
    }

    public final Collection<FinancialTransaction> listTransactions(LocalDateTime from, LocalDateTime to) {
        return Collections.unmodifiableCollection(
                this.transactions.stream().filter((transaction) -> {
                    return transaction.timestamp().isAfter(from) && transaction.timestamp().isBefore(to);
                })
            .toList());
    }

    public final void writeTransaction(final FinancialTransaction financialTransaction) {
        if (!this.isReadOnly) {
            this.transactions.add(financialTransaction);
        }
    }

    public final void writeAllTransactions(final FinancialTransaction... financialTransactions) {
        if (!this.isReadOnly) {
            this.transactions.addAll(Set.of(financialTransactions));
        }
    }

    public final void writeAllTransactions(final Collection<FinancialTransaction> financialTransactions) {
        if (!this.isReadOnly) {
            this.transactions.addAll(financialTransactions);
        }
    }

    public void close() {
        this.isReadOnly = true;
    }

}
package io.nirahtech.erp.bank;

import java.text.ParseException;

public final class IBANFactory {
    private IBANFactory() { }

    public static final InternationalBankAccountNumber create(final String iban) throws ParseException {
        return InternationalBankAccountNumber.parse(iban);
    }
}
package io.nirahtech.erp.bank;

import java.text.ParseException;
import java.util.Locale;
import java.util.Objects;

public final record InternationalBankAccountNumber(
    Locale country,
    int checkDigit,
    BasicBankAccountNumber accountNumber
) {

    private static final int MAX_IBAN_SIZE = 34;
    
    public static final InternationalBankAccountNumber parse(final String iban) throws ParseException {
        if (Objects.isNull(iban)) {
            throw new ParseException("IBAN cannot be 'null'.", 0);
        }
        if (iban.length() > MAX_IBAN_SIZE) {
            throw new ParseException("IBAN size cannot be greater than " + MAX_IBAN_SIZE, 0);
        }
        for (final char character : iban.toCharArray()) {
            if (!Character.isLetterOrDigit(character)) {
                throw new ParseException("Invalid character detected in IBAN : " + character, 0);
            }
        }

        final String countryCodeValue = iban.substring(0, 2);
        final String checkCodeValue = iban.substring(2, 4);
        
        for (final char character : checkCodeValue.toCharArray()) {
            if (!Character.isDigit(character)) {
                throw new ParseException("Invalid Check Code detected in IBAN : " + character, 0);
            }
        }

        final String accountNumberValue = iban.substring(4);

        final Locale country = Locale.forLanguageTag(countryCodeValue);
        final BasicBankAccountNumber bban = BasicBankAccountNumber.parse(accountNumberValue);

        return new InternationalBankAccountNumber(country, Integer.parseInt(checkCodeValue), bban);

    }
}
